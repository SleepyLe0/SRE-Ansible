- name: Set up virtual machine on Proxmox
  hosts: localhost
  vars:
    vm_name: bookcnk
    vm_template: ubuntu-cloud-template
    proxmox_node: int531-05
    proxmox_api_host: 10.13.104.215
    proxmox_api_user: root@pam
    proxmox_api_password: int53105
    proxmox_storage: local-lvm
    vm_target_ip: 10.13.104.81
    ssh_key_path: "{{ playbook_dir }}/privatekey"
  tasks:
    - name: Check if SSH key pair exists
      ansible.builtin.stat:
        path: "{{ ssh_key_path }}"
      register: ssh_key_stat

    - name: Generate SSH key pair if not exists
      community.crypto.openssh_keypair:
        path: "{{ ssh_key_path }}"
        type: ed25519
        comment: "sysadmin@{{ vm_target_ip }}"
        mode: '0600'
      register: ssh_keypair
      when: not ssh_key_stat.stat.exists

    - name: Read public key
      ansible.builtin.slurp:
        src: "{{ ssh_key_path }}.pub"
      register: ssh_pubkey

    - name: Set SSH public key fact
      ansible.builtin.set_fact:
        vm_ssh_pubkey: "{{ ssh_pubkey.content | b64decode | trim }}"

    - name: Ping my hosts
      ansible.builtin.ping:

    - name: Get VM current state
      community.proxmox.proxmox_kvm:
        api_user: "{{ proxmox_api_user }}"
        api_password: "{{ proxmox_api_password }}"
        api_host: "{{ proxmox_api_host }}"
        name: "{{ vm_name }}"
        node: "{{ proxmox_node }}"
        state: current
      register: vm_info
      ignore_errors: true

    - name: Stop the VM if running
      community.proxmox.proxmox_kvm:
        api_user: "{{ proxmox_api_user }}"
        api_password: "{{ proxmox_api_password }}"
        api_host: "{{ proxmox_api_host }}"
        name: "{{ vm_name }}"
        node: "{{ proxmox_node }}"
        state: stopped
        force: true
      when: vm_info.vmid is defined and vm_info.status ==  'running'

    - name: Remove VM
      community.proxmox.proxmox_kvm:
        api_user: "{{ proxmox_api_user }}"
        api_password: "{{ proxmox_api_password }}"
        api_host: "{{ proxmox_api_host }}"
        name: "{{ vm_name }}"
        node: "{{ proxmox_node }}"
        state: absent
      when: vm_info.vmid is defined

    - name: Create VM
      community.proxmox.proxmox_kvm:
        api_user: "{{ proxmox_api_user }}"
        api_password: "{{ proxmox_api_password }}"
        api_host: "{{ proxmox_api_host }}"
        clone: "{{ vm_template }}"
        name: "{{ vm_name }}"
        node: "{{ proxmox_node }}"
        timeout: 100
        full: false
      register: new_vm

    - name: Update VM configuration
      community.proxmox.proxmox_kvm:
        api_user: "{{ proxmox_api_user }}"
        api_password: "{{ proxmox_api_password }}"
        api_host: "{{ proxmox_api_host }}"
        node: "{{ proxmox_node }}"
        vmid: "{{ new_vm.vmid }}"
        ciuser: root
        cipassword: int53102
        sshkeys: "{{ vm_ssh_pubkey }}"
        nameservers: 8.8.8.8
        searchdomains: localdomain
        ipconfig:
          ipconfig0: 'ip={{ vm_target_ip }}/24,gw=10.13.104.254'
        update: yes

    - name: Start VM
      community.proxmox.proxmox_kvm:
        api_user: "{{ proxmox_api_user }}"
        api_password: "{{ proxmox_api_password }}"
        api_host: "{{ proxmox_api_host }}"
        vmid: "{{ new_vm.vmid }}"
        node: "{{ proxmox_node }}"
        state: started

    - name: Wait for VM to be reachable via SSH
      ansible.builtin.wait_for:
        host: "{{ vm_target_ip }}"
        port: 22
        delay: 30
        timeout: 300
        sleep: 5

    - name: Display SSH key path for debugging
      ansible.builtin.debug:
        msg: "SSH private key path: {{ ssh_key_path }}"

    - name: Verify SSH key exists
      ansible.builtin.stat:
        path: "{{ ssh_key_path }}"
      register: key_check

    - name: Display key status
      ansible.builtin.debug:
        msg: "SSH key exists: {{ key_check.stat.exists }}"

    - name: Test SSH connection manually
      ansible.builtin.command:
        cmd: "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o PreferredAuthentications=publickey -i {{ ssh_key_path }} root@{{ vm_target_ip }} echo 'SSH test successful'"
      register: ssh_test
      ignore_errors: yes
      changed_when: false

    - name: Display SSH test result
      ansible.builtin.debug:
        msg: "{{ ssh_test.stdout if ssh_test.rc == 0 else 'SSH test failed: ' + ssh_test.stderr }}"

    - name: Add new VM to inventory
      ansible.builtin.add_host:
        name: "{{ vm_target_ip }}"
        groups: new_vm
        ansible_host: "{{ vm_target_ip }}"
        ansible_user: root
        ansible_ssh_private_key_file: "{{ ssh_key_path }}"
        ansible_ssh_common_args: '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o PreferredAuthentications=publickey -o ControlMaster=no'
        ansible_password: null

- name: Configure the new VM hostname
  hosts: new_vm
  gather_facts: yes
  become: yes
  vars:
    ansible_ssh_pipelining: no
  tasks:
    - name: Wait for cloud-init to finish
      ansible.builtin.command: cloud-init status --wait
      changed_when: false
      register: cloud_init_status
      failed_when: cloud_init_status.rc not in [0, 2]

    - name: Wait for automatic system updates to complete
      ansible.builtin.shell: |
        # Wait for apt locks to be released
        timeout=600
        elapsed=0
        while [ $elapsed -lt $timeout ]; do
          if ! pgrep -x apt-get > /dev/null && ! pgrep -x dpkg > /dev/null && ! pgrep -x apt > /dev/null; then
            # Check if we can actually acquire the lock
            if ! fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 && ! fuser /var/lib/dpkg/lock >/dev/null 2>&1; then
              echo "All apt locks released"
              exit 0
            fi
          fi
          echo "Waiting for apt/dpkg processes to finish... (${elapsed}s elapsed)"
          sleep 10
          elapsed=$((elapsed + 10))
        done
        echo "Timeout waiting for apt locks"
        exit 1
      changed_when: false
      register: apt_wait
      timeout: 660

    - name: Kill any stuck apt processes if needed
      ansible.builtin.shell: |
        # Only if wait failed, try to clean up
        killall -9 apt-get apt dpkg 2>/dev/null || true
        rm -f /var/lib/dpkg/lock-frontend /var/lib/dpkg/lock /var/cache/apt/archives/lock 2>/dev/null || true
        dpkg --configure -a
      when: apt_wait.rc != 0
      ignore_errors: yes
      changed_when: false

    - name: Run apt update after waiting
      ansible.builtin.apt:
        update_cache: yes
        cache_valid_time: 0
      retries: 3
      delay: 10
      register: apt_update_result
      until: apt_update_result is succeeded

    - name: Disable unattended-upgrades temporarily
      ansible.builtin.systemd:
        name: unattended-upgrades
        state: stopped
        enabled: no
      ignore_errors: yes

    - name: Kill any remaining apt processes
      ansible.builtin.shell: |
        systemctl stop apt-daily.timer apt-daily-upgrade.timer
        systemctl disable apt-daily.timer apt-daily-upgrade.timer
        killall -9 apt-get apt dpkg 2>/dev/null || true
        rm -f /var/lib/dpkg/lock-frontend /var/lib/dpkg/lock /var/cache/apt/archives/lock 2>/dev/null || true
        dpkg --configure -a || true
      changed_when: false
      ignore_errors: yes

    - name: Final wait for apt
      ansible.builtin.pause:
        seconds: 5

    - name: Ensure all apt processes are completely finished
      ansible.builtin.shell: |
        # Wait for all apt-related processes to finish
        timeout=900
        elapsed=0
        while [ $elapsed -lt $timeout ]; do
          # Check for running apt processes
          if pgrep -x apt-get > /dev/null || pgrep -x apt > /dev/null || pgrep -x dpkg > /dev/null; then
            echo "Apt processes still running, waiting... (${elapsed}s elapsed)"
            sleep 5
            elapsed=$((elapsed + 5))
            continue
          fi
          
          # Check for lock files
          if fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 || \
             fuser /var/lib/dpkg/lock >/dev/null 2>&1 || \
             fuser /var/cache/apt/archives/lock >/dev/null 2>&1; then
            echo "Lock files still held, waiting... (${elapsed}s elapsed)"
            sleep 5
            elapsed=$((elapsed + 5))
            continue
          fi
          
          # Try to acquire the lock to verify it's actually free
          if lsof /var/lib/dpkg/lock-frontend >/dev/null 2>&1; then
            echo "Lock-frontend still in use, waiting... (${elapsed}s elapsed)"
            sleep 5
            elapsed=$((elapsed + 5))
            continue
          fi
          
          # All clear
          echo "All apt processes finished and locks released"
          exit 0
        done
        
        echo "Timeout waiting for apt processes (${timeout}s)"
        # Show what's still running
        echo "Running apt processes:"
        pgrep -a apt-get || echo "None"
        pgrep -a apt || echo "None"
        pgrep -a dpkg || echo "None"
        echo "Lock status:"
        lsof /var/lib/dpkg/lock-frontend 2>&1 || echo "Lock-frontend free"
        exit 1
      changed_when: false
      register: final_apt_wait
      timeout: 960

    - name: Force cleanup if apt wait failed
      ansible.builtin.shell: |
        # Kill any remaining apt processes
        killall -9 apt-get apt dpkg unattended-upgrades 2>/dev/null || true
        # Remove lock files
        rm -f /var/lib/dpkg/lock-frontend /var/lib/dpkg/lock /var/cache/apt/archives/lock 2>/dev/null || true
        # Fix any broken dpkg state
        dpkg --configure -a 2>&1 || true
        # Clean up any partial installations
        apt-get -f install -y 2>&1 || true
      when: final_apt_wait.rc != 0
      ignore_errors: yes
      changed_when: false

    - name: Verify apt is ready one final time
      ansible.builtin.command: |
        timeout 30 bash -c 'while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1; do sleep 1; done' || true
      changed_when: false

  roles:
    - common
    - app
    - monitor
